<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacezab" kind="namespace" language="C++">
    <compoundname>zab</compoundname>
    <innerclass refid="classzab_1_1async__barrier" prot="public">zab::async_barrier</innerclass>
    <innerclass refid="structzab_1_1directory" prot="public">zab::directory</innerclass>
    <innerclass refid="classzab_1_1async__file" prot="public">zab::async_file</innerclass>
    <innerclass refid="classzab_1_1async__function" prot="public">zab::async_function</innerclass>
    <innerclass refid="classzab_1_1async__latch" prot="public">zab::async_latch</innerclass>
    <innerclass refid="classzab_1_1async__mutex" prot="public">zab::async_mutex</innerclass>
    <innerclass refid="classzab_1_1async__counting__semaphore" prot="public">zab::async_counting_semaphore</innerclass>
    <innerclass refid="classzab_1_1async__counting__semaphore_3_011_01_4" prot="public">zab::async_counting_semaphore&lt; 1 &gt;</innerclass>
    <innerclass refid="structzab_1_1defer__block" prot="public">zab::defer_block</innerclass>
    <innerclass refid="structzab_1_1purge__block" prot="public">zab::purge_block</innerclass>
    <innerclass refid="classzab_1_1defer__block__promise" prot="public">zab::defer_block_promise</innerclass>
    <innerclass refid="classzab_1_1engine" prot="public">zab::engine</innerclass>
    <innerclass refid="classzab_1_1engine__enabled" prot="public">zab::engine_enabled</innerclass>
    <innerclass refid="structzab_1_1event" prot="public">zab::event</innerclass>
    <innerclass refid="structzab_1_1storage__event" prot="public">zab::storage_event</innerclass>
    <innerclass refid="structzab_1_1storage__event_3_01void_01_4" prot="public">zab::storage_event&lt; void &gt;</innerclass>
    <innerclass refid="classzab_1_1event__loop" prot="public">zab::event_loop</innerclass>
    <innerclass refid="classzab_1_1execution__promise" prot="public">zab::execution_promise</innerclass>
    <innerclass refid="structzab_1_1AwaitWrapper" prot="public">zab::AwaitWrapper</innerclass>
    <innerclass refid="classzab_1_1generic__awaitable" prot="public">zab::generic_awaitable</innerclass>
    <innerclass refid="classzab_1_1suspension__point" prot="public">zab::suspension_point</innerclass>
    <innerclass refid="classzab_1_1network__operation" prot="public">zab::network_operation</innerclass>
    <innerclass refid="classzab_1_1observable" prot="public">zab::observable</innerclass>
    <innerclass refid="structzab_1_1pause__pack" prot="public">zab::pause_pack</innerclass>
    <innerclass refid="classzab_1_1pause__token" prot="public">zab::pause_token</innerclass>
    <innerclass refid="classzab_1_1reusable__future" prot="public">zab::reusable_future</innerclass>
    <innerclass refid="classzab_1_1reusable__promise" prot="public">zab::reusable_promise</innerclass>
    <innerclass refid="classzab_1_1reusable__promise_3_01void_01_4" prot="public">zab::reusable_promise&lt; void &gt;</innerclass>
    <innerclass refid="classzab_1_1signal__handler" prot="public">zab::signal_handler</innerclass>
    <innerclass refid="structzab_1_1promise__void" prot="public">zab::promise_void</innerclass>
    <innerclass refid="structzab_1_1deduce__type" prot="public">zab::deduce_type</innerclass>
    <innerclass refid="structzab_1_1deduce__type_3_01void_01_4" prot="public">zab::deduce_type&lt; void &gt;</innerclass>
    <innerclass refid="classzab_1_1simple__future" prot="public">zab::simple_future</innerclass>
    <innerclass refid="classzab_1_1simple__common" prot="public">zab::simple_common</innerclass>
    <innerclass refid="classzab_1_1simple__promise" prot="public">zab::simple_promise</innerclass>
    <innerclass refid="structzab_1_1promise__always__resolves" prot="public">zab::promise_always_resolves</innerclass>
    <innerclass refid="classzab_1_1simple__promise_3_01promise__always__resolves_3_01T_01_4_01_4" prot="public">zab::simple_promise&lt; promise_always_resolves&lt; T &gt; &gt;</innerclass>
    <innerclass refid="classzab_1_1simple__promise_3_01void_01_4" prot="public">zab::simple_promise&lt; void &gt;</innerclass>
    <innerclass refid="classzab_1_1simple__promise_3_01bool_01_4" prot="public">zab::simple_promise&lt; bool &gt;</innerclass>
    <innerclass refid="structzab_1_1spin__lock" prot="public">zab::spin_lock</innerclass>
    <innerclass refid="structzab_1_1recursive__spin__lock" prot="public">zab::recursive_spin_lock</innerclass>
    <innerclass refid="classzab_1_1stateful__awaitable" prot="public">zab::stateful_awaitable</innerclass>
    <innerclass refid="structzab_1_1thread__t" prot="public">zab::thread_t</innerclass>
    <innerclass refid="structzab_1_1order__t" prot="public">zab::order_t</innerclass>
    <innerclass refid="classzab_1_1tcp__acceptor" prot="public">zab::tcp_acceptor</innerclass>
    <innerclass refid="classzab_1_1tcp__stream" prot="public">zab::tcp_stream</innerclass>
    <innerclass refid="classzab_1_1timer__service" prot="public">zab::timer_service</innerclass>
    <innerclass refid="classzab_1_1visitor__promise" prot="public">zab::visitor_promise</innerclass>
    <innerclass refid="classzab_1_1visitor__promise_3_01void_01_4" prot="public">zab::visitor_promise&lt; void &gt;</innerclass>
    <innernamespace refid="namespacezab_1_1details">zab::details</innernamespace>
    <innernamespace refid="namespacezab_1_1file">zab::file</innernamespace>
    <innernamespace refid="namespacezab_1_1order">zab::order</innernamespace>
    <innernamespace refid="namespacezab_1_1thread">zab::thread</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="for__each_8hpp_1a68b916f4722dbf416c134292c7477f5f" prot="public" static="no" strong="yes">
        <type></type>
        <name>for_ctl</name>
        <enumvalue id="for__each_8hpp_1a68b916f4722dbf416c134292c7477f5fab1cec4b5157c0bc35a95b44a2c1a36f0" prot="public">
          <name>kBreak</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="for__each_8hpp_1a68b916f4722dbf416c134292c7477f5fa234b41cc8342dc898d9100f4ca35098d" prot="public">
          <name>kContinue</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Controls for the for_each method, used to continue or break. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/for_each.hpp" line="51" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/for_each.hpp" bodystart="51" bodyend="54"/>
      </memberdef>
      <memberdef kind="enum" id="stateful__awaitable_8hpp_1ae08f88389e2d5da971f841e3265d3db6" prot="public" static="no" strong="yes">
        <type></type>
        <name>notify_ctl</name>
        <enumvalue id="stateful__awaitable_8hpp_1ae08f88389e2d5da971f841e3265d3db6a3cce98af66db8fecc27ee60ad140eb2b" prot="public">
          <name>kSuspend</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="stateful__awaitable_8hpp_1ae08f88389e2d5da971f841e3265d3db6a4d39cb21151dcb67f4c04220140c34f0" prot="public">
          <name>kResume</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="stateful__awaitable_8hpp_1ae08f88389e2d5da971f841e3265d3db6a25d5606fe07425ea73f245c48612c039" prot="public">
          <name>kReady</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" line="45" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" bodystart="45" bodyend="49"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="async__semaphore_8hpp_1ab8d7e7aa8d2419caa6aed39301bd4d51" prot="public" static="no">
        <type>async_counting_semaphore&lt; 1 &gt;</type>
        <definition>using zab::async_binary_semaphore = typedef async_counting_semaphore&lt;1&gt;</definition>
        <argsstring></argsstring>
        <name>async_binary_semaphore</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/async_semaphore.hpp" line="431" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/async_semaphore.hpp" bodystart="431" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="event_8hpp_1af02f805e6ddec01e962e6f8f57dce11b" prot="public" static="no">
        <type>std::variant&lt; event&lt;&gt;, std::coroutine_handle&lt;&gt; &gt;</type>
        <definition>using zab::tagged_event = typedef std::variant&lt;event&lt;&gt;, std::coroutine_handle&lt;&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>tagged_event</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="73" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="simple__future_8hpp_1aadd31e08f84d24f721410cf5c92efaa2" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classzab_1_1simple__future" kindref="compound">simple_future</ref>&lt; <ref refid="structzab_1_1promise__always__resolves" kindref="compound">promise_always_resolves</ref>&lt; T &gt;, <ref refid="classzab_1_1simple__promise" kindref="compound">simple_promise</ref>&lt; <ref refid="structzab_1_1promise__always__resolves" kindref="compound">promise_always_resolves</ref>&lt; T &gt; &gt;&gt;</type>
        <definition>using zab::guaranteed_future = typedef simple_future&lt;promise_always_resolves&lt;T&gt;, simple_promise&lt;promise_always_resolves&lt;T&gt; &gt;&gt;</definition>
        <argsstring></argsstring>
        <name>guaranteed_future</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convenience for when the promise will always resolve. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/simple_future.hpp" line="237" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/simple_future.hpp" bodystart="238" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="visitor__promise_8hpp_1aed43df122c3d1840c2dc205e84d1824c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
            <defval>void</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classzab_1_1simple__future" kindref="compound">simple_future</ref>&lt; T, visitor_promise&lt; T &gt; &gt;</type>
        <definition>using zab::visitor_future = typedef simple_future&lt;T, visitor_promise&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>visitor_future</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/visitor_promise.hpp" line="49" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/visitor_promise.hpp" bodystart="49" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="for__each_8hpp_1ab86f7a59e8aa820062fbfb09262d1c8d" prot="public" static="no" mutable="no">
        <type>P &amp;&amp;</type>
        <definition>P&amp;&amp; zab::_reusable</definition>
        <argsstring></argsstring>
        <name>_reusable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/for_each.hpp" line="78" column="8" bodyfile="/home/donald/rupin/zab/includes/zab/for_each.hpp" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="memory__type_8hpp_1ac911484e178888ec8e6f66c6b88224f6" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>concept</type>
        <definition>concept zab::MemoryType</definition>
        <argsstring></argsstring>
        <name>MemoryType</name>
        <initializer>= std::is_same_v&lt;Type, std::byte&gt; || std::is_same_v&lt;Type, char&gt; ||
        std::is_same_v&lt;Type, unsigned char&gt;</initializer>
        <briefdescription>
<para>Possible types for underlying memory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/memory_type.hpp" line="52" column="13" bodyfile="/home/donald/rupin/zab/includes/zab/memory_type.hpp" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="event__loop_8cpp_1a9c5dfcb4179a20685d6e5e35b529fb7c" prot="public" static="yes" mutable="no">
        <type>const std::uint64_t</type>
        <definition>const std::uint64_t zab::item</definition>
        <argsstring></argsstring>
        <name>item</name>
        <initializer>= 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/src/event_loop.cpp" line="396" column="32" bodyfile="/home/donald/rupin/zab/src/event_loop.cpp" bodystart="396" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="event_8hpp_1a19c67561e0b8ecb6e46392d0884caa22" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool zab::is_coroutine</definition>
        <argsstring>(tagged_event _event)</argsstring>
        <name>is_coroutine</name>
        <param>
          <type>tagged_event</type>
          <declname>_event</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="87" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="87" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a0706421739f18a35fc8a746951803c7f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ReturnType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(event&lt; ReturnType &gt; *_event_address, ReturnType _result) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>event&lt; ReturnType &gt; *</type>
          <declname>_event_address</declname>
        </param>
        <param>
          <type>ReturnType</type>
          <declname>_result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="94" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="94" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a321e3df2d4971922cd85c0b4f230e1f4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(event&lt;&gt; *_event_address) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>event&lt;&gt; *</type>
          <declname>_event_address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="100" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="100" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a065a09c2804946629e4418943a0155f6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(event&lt;&gt; _event_address) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>event&lt;&gt;</type>
          <declname>_event_address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="106" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="106" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a4f100d73214af4023f3d359d42af537b" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(std::coroutine_handle&lt;&gt; _handle) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>std::coroutine_handle&lt;&gt;</type>
          <declname>_handle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="112" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="112" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a3fe35bb965eaf6b67496cf4d14665c9b" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(tagged_event *_event_address) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>tagged_event *</type>
          <declname>_event_address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="118" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="118" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a0d1c7ea01ea0c577a4a12d88fdd54aec" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(tagged_event _event_address) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>tagged_event</type>
          <declname>_event_address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="124" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="124" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1af4f2d2bb35e9621e50a4bc1bec344fcd" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EventType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void zab::execute_event</definition>
        <argsstring>(storage_event&lt; EventType &gt; *_event_address, EventType _result) noexcept</argsstring>
        <name>execute_event</name>
        <param>
          <type>storage_event&lt; EventType &gt; *</type>
          <declname>_event_address</declname>
        </param>
        <param>
          <type>EventType</type>
          <declname>_result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="131" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="131" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a1509d9c3fac8ae182ca317d2295b53f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EventType</type>
          </param>
        </templateparamlist>
        <type>event&lt; EventType &gt;</type>
        <definition>event&lt;EventType&gt; zab::create_generic_event</definition>
        <argsstring>(storage_event&lt; EventType &gt; *_event)</argsstring>
        <name>create_generic_event</name>
        <param>
          <type>storage_event&lt; EventType &gt; *</type>
          <declname>_event</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="148" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="148" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1a745d1b9f18f2164440890dc3c33cc3f9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>event</type>
        <definition>event zab::create_generic_event</definition>
        <argsstring>(std::coroutine_handle&lt;&gt; _handle)</argsstring>
        <name>create_generic_event</name>
        <param>
          <type>std::coroutine_handle&lt;&gt;</type>
          <declname>_handle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="163" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="163" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="event_8hpp_1aaef40f88663a50734e524c46dfe67448" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>event</type>
        <definition>event zab::get_event</definition>
        <argsstring>(tagged_event _event)</argsstring>
        <name>get_event</name>
        <param>
          <type>tagged_event</type>
          <declname>_event</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/event.hpp" line="173" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/event.hpp" bodystart="173" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="first__of_8hpp_1a56c5f1c9f912bc6781ad8990a752234d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Promises</declname>
            <defname>Promises</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classzab_1_1simple__future" kindref="compound">guaranteed_future</ref>&lt; typename details::one_of_these&lt; typename <ref refid="structzab_1_1details_1_1extract__promise__types" kindref="compound">details::extract_promise_types</ref>&lt; Promises... &gt;::types &gt;::types &gt;</type>
        <definition>guaranteed_future&lt;typename details::one_of_these&lt; typename details::extract_promise_types&lt;Promises...&gt;::types&gt;::types&gt; zab::first_of</definition>
        <argsstring>(engine *_engine, Promises &amp;&amp;... _args)</argsstring>
        <name>first_of</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type>Promises &amp;&amp;...</type>
          <declname>_args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/first_of.hpp" line="101" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/first_of.hpp" bodystart="101" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="for__each_8hpp_1af936a752463508e573b945cd68539ce2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename Functor</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>zab::requires</definition>
        <argsstring>((std::is_same_v&lt; std::result_of_t&lt; Functor(typename reusable_future&lt; T, P &gt;::return_value)&gt;, void &gt;||std::is_same_v&lt; std::result_of_t&lt; Functor(typename reusable_future&lt; T, P &gt;::return_value)&gt;, for_ctl &gt;)) simple_future&lt;&gt; for_each(reusable_future&lt; T</argsstring>
        <name>requires</name>
        <param>
          <type>(std::is_same_v&lt; std::result_of_t&lt; Functor(typename <ref refid="classzab_1_1reusable__future" kindref="compound">reusable_future</ref>&lt; T, P &gt;::return_value)&gt;, void &gt;||std::is_same_v&lt; std::result_of_t&lt; Functor(typename <ref refid="classzab_1_1reusable__future" kindref="compound">reusable_future</ref>&lt; T, P &gt;::return_value)&gt;, for_ctl &gt;)</type>
        </param>
        <briefdescription>
<para>Iterate through results of the resuable_future giving the results to the callback. </para>
        </briefdescription>
        <detaileddescription>
<para>Resumes when the function signals completion.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_reusable</parametername>
</parameternamelist>
<parameterdescription>
<para>The reusable future. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_functor</parametername>
</parameternamelist>
<parameterdescription>
<para>The functor give the results.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The template type for the <ref refid="classzab_1_1reusable__future" kindref="compound">reusable_future</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>The promise type for the <ref refid="classzab_1_1reusable__future" kindref="compound">reusable_future</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Functor</parametername>
</parameternamelist>
<parameterdescription>
<para>The functor to use. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/for_each.hpp" line="70" column="9"/>
      </memberdef>
      <memberdef kind="function" id="generic__awaitable_8hpp_1a83a1bc258fae0417e522fa100ac95691" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>static constexpr bool zab::is_suspend</definition>
        <argsstring>()</argsstring>
        <name>is_suspend</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" line="120" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="generic__awaitable_8hpp_1a75a96e5632a7ad9587e7a48f1eb462e7" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>static constexpr bool zab::is_ready</definition>
        <argsstring>()</argsstring>
        <name>is_ready</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" line="127" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" bodystart="127" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="generic__awaitable_8hpp_1a684f1fcbc5e30c7d0f4a684cd7a64b7b" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>static constexpr bool zab::is_resume</definition>
        <argsstring>()</argsstring>
        <name>is_resume</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" line="134" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/generic_awaitable.hpp" bodystart="134" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="pause_8hpp_1a5ec6e5c2cc57f4a3003cea695973e2a8" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>details::NoThrowInvoacablePP</type>
            <declname>Functor</declname>
            <defname>Functor</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto zab::pause</definition>
        <argsstring>(Functor &amp;&amp;_func) noexcept</argsstring>
        <name>pause</name>
        <param>
          <type>Functor &amp;&amp;</type>
          <declname>_func</declname>
        </param>
        <briefdescription>
<para>Suspend a coroutine until unpause is called. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Functor</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_func</parametername>
</parameternamelist>
<parameterdescription>
<para>The callable that is given the pause_pack* for resumption. @co_return std::intptr_t The value of pause_pack-&gt;data_ given to the Functor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/pause.hpp" line="97" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/pause.hpp" bodystart="97" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="pause_8hpp_1a4eeff482493e4a80f8054e2df402a222" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::unpause</definition>
        <argsstring>(engine *_engine, pause_pack &amp;_pause, order_t _order) noexcept</argsstring>
        <name>unpause</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1pause__pack" kindref="compound">pause_pack</ref> &amp;</type>
          <declname>_pause</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1order__t" kindref="compound">order_t</ref></type>
          <declname>_order</declname>
        </param>
        <briefdescription>
<para>Continues a paused corountine. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_pause</parametername>
</parameternamelist>
<parameterdescription>
<para>The pause pack to resume. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_order</parametername>
</parameternamelist>
<parameterdescription>
<para>The ordering to apply. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/src/pause.cpp" line="46" column="5" bodyfile="/home/donald/rupin/zab/src/pause.cpp" bodystart="46" bodyend="49" declfile="/home/donald/rupin/zab/includes/zab/pause.hpp" declline="124" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="pause_8hpp_1a2b20a3101db006fd04b8afafcd7c06ef" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::unpause</definition>
        <argsstring>(engine *_engine, pause_pack &amp;_pause) noexcept</argsstring>
        <name>unpause</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1pause__pack" kindref="compound">pause_pack</ref> &amp;</type>
          <declname>_pause</declname>
        </param>
        <briefdescription>
<para>Continues a paused corountine. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_pause</parametername>
</parameternamelist>
<parameterdescription>
<para>The pause pack to resume. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/src/pause.cpp" line="52" column="5" bodyfile="/home/donald/rupin/zab/src/pause.cpp" bodystart="52" bodyend="55" declfile="/home/donald/rupin/zab/includes/zab/pause.hpp" declline="132" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="stateful__awaitable_8hpp_1aaa3a1c214d8091a5147d93771b976013" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NotifyType</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>static constexpr bool zab::is_stateful_suspend</definition>
        <argsstring>()</argsstring>
        <name>is_stateful_suspend</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" line="87" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" bodystart="87" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="stateful__awaitable_8hpp_1a8139ac8ef412e3cfb716339d712ce5e1" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NotifyType</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>static constexpr bool zab::is_notify</definition>
        <argsstring>()</argsstring>
        <name>is_notify</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" line="94" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" bodystart="94" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="stateful__awaitable_8hpp_1a1207bb945eca3f44e2190175ea3ab54c" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NotifyType</type>
          </param>
          <param>
            <type>details::StatefulAwaitable&lt; NotifyType &gt;</type>
            <declname>Functor</declname>
            <defname>Functor</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto zab::stateful_suspension_point</definition>
        <argsstring>(Functor &amp;&amp;_functor) noexcept</argsstring>
        <name>stateful_suspension_point</name>
        <param>
          <type>Functor &amp;&amp;</type>
          <declname>_functor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" line="252" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/stateful_awaitable.hpp" bodystart="252" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="strong__types_8hpp_1a20035a83baa3d8092bb6432914207dac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; zab::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;_os, const thread_t _thread)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>_os</declname>
        </param>
        <param>
          <type>const <ref refid="structzab_1_1thread__t" kindref="compound">thread_t</ref></type>
          <declname>_thread</declname>
        </param>
        <briefdescription>
<para>Print the value of a thread to a stream. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_os</parametername>
</parameternamelist>
<parameterdescription>
<para>The out stream. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread to print. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::ostream&amp; _os </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/strong_types.hpp" line="191" column="12" bodyfile="/home/donald/rupin/zab/includes/zab/strong_types.hpp" bodystart="192" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="tcp__networking_8hpp_1a2fadff169b20c8b5ec32226b72c7ed25" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>MemoryType</type>
            <declname>DataType</declname>
            <defname>DataType</defname>
            <defval>std::byte</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto zab::tcp_connect</definition>
        <argsstring>(engine *_engine, const struct sockaddr *_details, socklen_t _size, event_loop::io_event **cancel_token_=nullptr, int _sock_flags=SOCK_CLOEXEC)</argsstring>
        <name>tcp_connect</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type>const struct sockaddr *</type>
          <declname>_details</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>_size</declname>
        </param>
        <param>
          <type>event_loop::io_event **</type>
          <declname>cancel_token_</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>int</type>
          <declname>_sock_flags</declname>
          <defval>SOCK_CLOEXEC</defval>
        </param>
        <briefdescription>
<para>A free function for connecting to a server. </para>
        </briefdescription>
        <detaileddescription>
<para>This function suspends only if there is no error on socket creation. <verbatim>     This function is cancelable using the event loop and the value filled out on
     cancel_token_.

     This function is equivelent to calling `::socket()` and `::connect()`.
</verbatim> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DataType</parametername>
</parameternamelist>
<parameterdescription>
<para>The memory type of the tcp stream. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_engine</parametername>
</parameternamelist>
<parameterdescription>
<para>The engine to use. It is expected that the caller is currently in an engines thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_details</parametername>
</parameternamelist>
<parameterdescription>
<para>The sockaddr* uses that is pre-filled out with the connection details. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory region used by _details. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cancel_token_</parametername>
</parameternamelist>
<parameterdescription>
<para>An option <computeroutput>cancel_token_</computeroutput> that can be passed in that can be used to the cancel the operation. If a io_handle* is passed it it will be set before suspension. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_sock_flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to apply to the socket during socket creation. The SOCK_STREAM is always given, SOCK_CLOEXEC is the default. @co_return <ref refid="classzab_1_1tcp__stream" kindref="compound">tcp_stream</ref> A stream is always returned to take ownership of the connector socket. If an error occurred the streams last_error is set. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/tcp_networking.hpp" line="222" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/tcp_networking.hpp" bodystart="222" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="wait__for_8hpp_1a616774f77dfa9b6abd36b9908b6d10ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Promises</declname>
            <defname>Promises</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classzab_1_1simple__future" kindref="compound">guaranteed_future</ref>&lt; typename <ref refid="structzab_1_1details_1_1extract__promise__types" kindref="compound">details::extract_promise_types</ref>&lt; Promises... &gt;::types &gt;</type>
        <definition>guaranteed_future&lt;typename details::extract_promise_types&lt;Promises...&gt;::types&gt; zab::wait_for</definition>
        <argsstring>(engine *_engine, Promises &amp;&amp;... _args)</argsstring>
        <name>wait_for</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type>Promises &amp;&amp;...</type>
          <declname>_args</declname>
        </param>
        <briefdescription>
<para>Given a variable amount of simple_promises, calls them in parallel and returns the results after all have complete. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_engine</parametername>
</parameternamelist>
<parameterdescription>
<para>The engine to use for setting up. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread to return into. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_args</parametername>
</parameternamelist>
<parameterdescription>
<para>The simple_promises</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Promises</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of the simple_promises.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A guaranteed_future that promises to get all of the results. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/wait_for.hpp" line="235" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/wait_for.hpp" bodystart="235" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="wait__for_8hpp_1a168c653aff066ad010f15b9aafb08fe3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classzab_1_1simple__future" kindref="compound">guaranteed_future</ref>&lt; std::vector&lt; typename <ref refid="classzab_1_1simple__future" kindref="compound">simple_future</ref>&lt; T &gt;::return_value &gt; &gt;</type>
        <definition>guaranteed_future&lt;std::vector&lt;typename simple_future&lt;T&gt;::return_value&gt; &gt; zab::wait_for</definition>
        <argsstring>(engine *_engine, std::vector&lt; simple_future&lt; T &gt;&gt; &amp;&amp;_args)</argsstring>
        <name>wait_for</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classzab_1_1simple__future" kindref="compound">simple_future</ref>&lt; T &gt;&gt; &amp;&amp;</type>
          <declname>_args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/wait_for.hpp" line="280" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/wait_for.hpp" bodystart="280" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="yield_8hpp_1a9f83f27de681fd37f50914c9fe561812" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto zab::yield</definition>
        <argsstring>(engine *_engine) noexcept</argsstring>
        <name>yield</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <briefdescription>
<para>Yields execution of the current coroutine. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_engine</parametername>
</parameternamelist>
<parameterdescription>
<para>The engine to yield into.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
@co_return void Will be resumed by the engine in the current thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/yield.hpp" line="56" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/yield.hpp" bodystart="56" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="yield_8hpp_1a05abe866a3a440b99d53668a63a1dea4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto zab::yield</definition>
        <argsstring>(engine *_engine, thread_t _thread) noexcept</argsstring>
        <name>yield</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1thread__t" kindref="compound">thread_t</ref></type>
          <declname>_thread</declname>
        </param>
        <briefdescription>
<para>Yields execution of the current coroutine. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_engine</parametername>
</parameternamelist>
<parameterdescription>
<para>The engine to yield into. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread to resume in.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
@co_return void Will be resumed by the engine in _thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/yield.hpp" line="74" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/yield.hpp" bodystart="74" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="yield_8hpp_1aa1e9252e42ea1942d152395ed03ee305" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto zab::yield</definition>
        <argsstring>(engine *_engine, order_t _order, thread_t _thread) noexcept</argsstring>
        <name>yield</name>
        <param>
          <type><ref refid="classzab_1_1engine" kindref="compound">engine</ref> *</type>
          <declname>_engine</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1order__t" kindref="compound">order_t</ref></type>
          <declname>_order</declname>
        </param>
        <param>
          <type><ref refid="structzab_1_1thread__t" kindref="compound">thread_t</ref></type>
          <declname>_thread</declname>
        </param>
        <briefdescription>
<para>Yields execution of the current coroutine. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_engine</parametername>
</parameternamelist>
<parameterdescription>
<para>The engine to yield into. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_order</parametername>
</parameternamelist>
<parameterdescription>
<para>The orderring to apply to the event loop. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread to resume in.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
@co_return void Will be resumed by the engine in _thread after _order nanoseconds have passed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/includes/zab/yield.hpp" line="97" column="5" bodyfile="/home/donald/rupin/zab/includes/zab/yield.hpp" bodystart="97" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="network__operation_8cpp_1abf5a5f706288479fb64aad0d8963e36f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::swap</definition>
        <argsstring>(network_operation &amp;_first, network_operation &amp;_second) noexcept</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classzab_1_1network__operation" kindref="compound">network_operation</ref> &amp;</type>
          <declname>_first</declname>
        </param>
        <param>
          <type><ref refid="classzab_1_1network__operation" kindref="compound">network_operation</ref> &amp;</type>
          <declname>_second</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_first</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="classzab_1_1network__operation" kindref="compound">network_operation</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_second</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="classzab_1_1network__operation" kindref="compound">network_operation</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/src/network_operation.cpp" line="89" column="5" bodyfile="/home/donald/rupin/zab/src/network_operation.cpp" bodystart="89" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="tcp__networking_8cpp_1ae35268e933a8b4e80e32beb88e1cfde4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void zab::swap</definition>
        <argsstring>(tcp_acceptor &amp;_first, tcp_acceptor &amp;_second) noexcept</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classzab_1_1tcp__acceptor" kindref="compound">tcp_acceptor</ref> &amp;</type>
          <declname>_first</declname>
        </param>
        <param>
          <type><ref refid="classzab_1_1tcp__acceptor" kindref="compound">tcp_acceptor</ref> &amp;</type>
          <declname>_second</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_first</parametername>
</parameternamelist>
<parameterdescription>
<para>The first </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_second</parametername>
</parameternamelist>
<parameterdescription>
<para>The second </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/donald/rupin/zab/src/tcp_networking.cpp" line="55" column="5" bodyfile="/home/donald/rupin/zab/src/tcp_networking.cpp" bodystart="55" bodyend="59"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/donald/rupin/zab/includes/zab/async_barrier.hpp" line="55" column="1"/>
  </compounddef>
</doxygen>
